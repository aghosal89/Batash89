%Generating X_i's and Y_i's ~
n=20;
nsim=15;
x1=rand(n,nsim);
x2=rand(n,nsim);

tau=[0.2 0.35];

u1 = tau(1)*randn(20, 15); u2 = tau(1)*randn(20, 15); % low noise Normal with N(0,(tau(1))^2) components 
v1 = tau(2)*randn(20, 15); v2 = tau(2)*randn(20, 15); 

%mreg1 = arrayfun(@(j) reg_curve(x1(:, j))', 1:nsim, 'UniformOutput', false);
%mreg2 = arrayfun(@(j) reg_curve(x2(:, j))', 1:nsim, 'UniformOutput', false);

%Y1 = get_shere_fit(reg_curve(x1(:, 1))', [u1(1, :) u2(1, :)]);
Y1 = add_noise(reg_curve(x1(:, 1))', [u1(1, :) u2(1, :)]);

%Defining the kernel function:

Kmat = repmat(NaN, 20, 20);
beta=0.1;
h=0.35;
X=x1(:,1)*beta + x2(:,1)*sqrt(1-beta^2)
for i = 1:size(X,1)
    for j = 1:size(X,1)
        %if(j~=i)
         Kmat(i,j) = epKernel(X(i,1),X(j,1),h)
    end
end

%The diagonal elements are non-zero so we have to deduct them,

Kmat*Y1.'

