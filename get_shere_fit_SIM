
n=20;
nsim=15;
x1=rand(n,nsim);
x2=rand(n,nsim);

tau=[0.2 0.35];

u1 = tau(1)*randn(20, 15); u2 = tau(1)*randn(20, 15); % low noise Normal with N(0,(tau(1))^2) components 
v1 = tau(2)*randn(20, 15); v2 = tau(2)*randn(20, 15); 

mreg1 = arrayfun(@(j) reg_curve(x1(:, j))', 1:nsim, 'UniformOutput', false);
mreg2 = arrayfun(@(j) reg_curve(x2(:, j))', 1:nsim, 'UniformOutput', false);

Y1 = cell2mat(arrayfun(@(j) add_noise(mreg1{1}(:, j), [u1(j, 1) u2(j, 1)]), 1:n, 'UniformOutput', false));
Y2 = cell2mat(arrayfun(@(j) add_noise(mreg2{1}(:, j), [v1(j, 1) v2(j, 1)]), 1:n, 'UniformOutput', false));

%xout=linspace(0,1,)
%Defining the kernel function:

Kmat= repmat(NaN, 20, 20);
beta= 0:0.05:1;
h=0.5;
Y_hat=repmat(NaN, 20, 3);
dvec=repmat(NaN, length(beta), nsim);

for l=1:nsim
    for k=1:length(beta)
    X=x1*beta(k) + x2*sqrt(1-beta(k)^2);
    for i =1:n
        for j=1:n
            Kmat(i,j) = epKernel(X(i,l),X(j,l),h);
            if j==i 
                Kmat(i,j)=0;
            end
        Y_hat(i, :)= Y1*Kmat(i,:)'/(sum(Kmat(i,:)));
        end
    end
%The diagonal elements are non-zero so we have to deduct them,

dvec(k,l) =mean(arrayfun(@(i) (acos(Y_hat(i,:)*Y1(:,i)))^2, 1:n));
    end
end

               
%Creating the predicted Y - values                      
Y_hat=repmat(NaN, 20, 3);

for i=1:size(Y_hat, 1)
    Y_hat(i,:)= (Y1*Kmat(:,i))'-Y1(:,i)'*Kmat(i,i);
end


%Calculating the geodesic distance between the points

dvec = arrayfun(@(i) Y_hat(i,:)*Y1(:,i), 1:20)
    
mean(acos(dvec))


