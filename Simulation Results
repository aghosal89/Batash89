% Sphere simulations

addpath(genpath('Manopt_2.0'))
%addpath sphere_spline

nsim=10;
n=200;
reg_curve = @(t) [sqrt(1-t.^2).*cos(pi*t), sqrt(1-t.^2).*sin(pi*t), t];
beta=0.01:0.03:1;
h=0.25;
dvec=repmat(NaN, length(beta), nsim);
beta_opt=repmat(NaN, nsim, 1);

%Generating the data from fixed beta value~
b=0.15;

[u1,u2,x1,x2,Y_frf] = sphere_sims_SIM2(19845, nsim, n, [0.2 0.35], h , b);

for i = 1:nsim
disp(i)    
for r = 1:length(beta)
    
disp(r)
ztemp= (beta(r)*x1(:, i) + (1 - beta(r).^2)*x2(:, i))/(beta(r)+sqrt(1-beta(r).^2));
mreg1 = reg_curve(ztemp);
  %mreg2 = arrayfun(@(j) reg_curve(z2(:, j))', 1:nsim, 'UniformOutput', false);

  M = spherefactory(3);
  fr = struct(); lc = struct(); ops = struct();
  fr.M = M; lc.M = M; ops.verbosity = 0;

Y_fr = arrayfun(@(l) zeros(3, size(ztemp,1), length(h)), 1:nsim, 'UniformOutput', false);

% Generate noisy data
Y1 = cell2mat(arrayfun(@(j) add_noise(mreg1(j, :)', [u1(j, i) u2(j, i)]), 1:size(ztemp,1), 'UniformOutput', false));
  	%Y2 = cell2mat(arrayfun(@(j) add_noise(mreg2{i}(:, j), [v1(j, i) v2(j, i)]), 1:n, 'UniformOutput', false));

    for l = 1:length(h)

       Y_fr = get_sphere_fit_SIM2(Y1, ztemp, h(l));

    end
  
dvec(r,i) = mean((arrayfun(@(l) acos(Y_frf{i}(:, l)'*Y_fr(:,l)),1:n)).^2); 
  
  end


end

save correctedsphere_results_n200_nsim10_SIM3_h0.25_b0.15.mat  Y_frf * dvec

load correctedsphere_results_n200_nsim10_SIM3_h0.25_b0.15.mat

plot( 0.01:0.03:1, dvec)
xlabel('Beta')
ylabel('MSE')
title('MSE variation for n=200, nsim=10, h=0.25')
xline(0.15);








%The following are the functions used to run in main code:


function [u1,u2,x1,x2,Y_fr] = sphere_sims_SIM2(s, nsim, n, tau, h, beta)

  rng(s)
  reg_curve = @(t) [sqrt(1-t.^2).*cos(pi*t), sqrt(1-t.^2).*sin(pi*t), t];
  pm = struct('s', s, 'nsim', nsim, 'n', n, 'tau', tau, 'h', h, 'beta', beta);

  % Generate noise vectors and predictors

  u1 = tau(1)*randn(n, nsim); u2 = tau(1)*randn(n, nsim); % low noise components
  %v1 = tau(2)*randn(n, nsim); v2 = tau(2)*randn(n, nsim); % high noise components

  x1 = rand(n, nsim); x2 = rand(n, nsim);

  z= (beta*x1 + (1 - beta.^2)*x2)/(beta+sqrt(1-beta.^2));
  %z2 = (beta*x1 - (1 - beta.^2)*x2)/(beta+sqrt(1-beta.^2));
  % Regression values at predictors
  
  mreg1 = arrayfun(@(j) reg_curve(z(:, j))', 1:nsim, 'UniformOutput', false);
  %mreg2 = arrayfun(@(j) reg_curve(z2(:, j))', 1:nsim, 'UniformOutput', false);

  % Grids and variable storage

  M = spherefactory(3);
  fr = struct(); lc = struct(); ops = struct();
  fr.M = M; lc.M = M; ops.verbosity = 0;
  %xout = linspace(0, 1, 51);
  
  Y_fr = arrayfun(@(l) zeros(3, size(z,1), length(h)), 1:nsim, 'UniformOutput', false);
  %Y_fr2 = arrayfun(@(l) zeros(3, size(z2, 1), length(h)), 1:nsim, 'UniformOutput', false);
%  Y_lc2 = Y_fr2;

  %pool = parpool(12);
  %parfor i = 1:nsim % run simulations in parallel
  for i = 1:nsim

    disp(i)
    
  	% Generate noisy data
    Y1 = cell2mat(arrayfun(@(j) add_noise(mreg1{i}(:, j), [u1(j, i) u2(j, i)]), 1:size(z,1), 'UniformOutput', false));
  	%Y2 = cell2mat(arrayfun(@(j) add_noise(mreg2{i}(:, j), [v1(j, i) v2(j, i)]), 1:n, 'UniformOutput', false));

    for l = 1:length(h)

       Y_fr{i}(:, :, l) = get_sphere_fit_SIM(Y1, z(:, i), h(l));

    end

  end
  %delete(pool)

end








function fr_fit = get_sphere_fit_SIM2(Y, z, h)

  n = length(z);
  lc_fit = zeros(3, length(z));
  fr_fit = lc_fit;
  M = spherefactory(3);
  ops.verbosity = 0;
  fr.M = M; lc.M = M;

  % Get weights
  zdiff = repmat(z, 1, length(z)) - repmat(z', length(z), 1);
  Kmat = 0.75*(1 - (zdiff/h).^2).*(abs(zdiff)<= h);
  mu0 = mean(Kmat);  mu1 = mean(Kmat.*zdiff); mu2 = mean(Kmat.*(zdiff.^2));
  sig2 = mu0.*mu2 - mu1.^2;
  w = Kmat.*(repmat(mu2, length(z), 1) - repmat(mu1, length(z), 1).*zdiff)./repmat(sig2, length(z), 1);

  for j = 1:length(z)

    y0 = sum(cell2mat(arrayfun(@(k) w(k, j)*Y(:, k), 1:n, 'UniformOutput', false))')'; y0 = y0/norm(y0); % Initial guess (extrinsic)

    %Compute cost and Euclidean gradient

    if(length(find(w(:, j))) < 2)

      fr_fit(:, j) = repmat(NaN, 1, 3);

    else

      fr.cost = @(y) get_cost(w(:, j)', Y, y, M);
      fr.egrad = @(y) get_egrad(w(:, j)', Y, y, M);
      fr.ehess = @(y, u) get_ehess(w(:, j)', Y, y, M, u);

      fr_fit(:, j) = trustregions(fr, y0, ops);
    
  end

end


