%The function get_sphere_fit_SIM



%% Get sphere fits for simulations

function [lc_fit fr_fit] = get_sphere_fit_SIM(Y, z, h)

  n = length(z);
  lc_fit = zeros(3, length(z));
  fr_fit = lc_fit;
  M = spherefactory(3);
  ops.verbosity = 0;
  fr.M = M; lc.M = M;

  % Get weights
  zdiff = repmat(z, 1, length(z)) - repmat(z', length(z), 1);
  Kmat = 0.75*(1 - (zdiff/h).^2).*(abs(zdiff)<= h);
  mu0 = mean(Kmat);  mu1 = mean(Kmat.*zdiff); mu2 = mean(Kmat.*(zdiff.^2));
  sig2 = mu0.*mu2 - mu1.^2;
  w = Kmat.*(repmat(mu2, length(z), 1) - repmat(mu1, length(z), 1).*zdiff)./repmat(sig2, length(z), 1);

  for j = 1:length(z)

    y0 = sum(cell2mat(arrayfun(@(k) w(k, j)*Y(:, k), 1:n, 'UniformOutput', false))')'; y0 = y0/norm(y0); % Initial guess (extrinsic)

    %Compute cost and Euclidean gradient

    if(length(find(w(:, j))) < 2)

      fr_fit(:, j) = repmat(NaN, 1, 3);

    else

      fr.cost = @(y) get_cost(w(:, j)', Y, y, M);
      fr.egrad = @(y) get_egrad(w(:, j)', Y, y, M);
      fr.ehess = @(y, u) get_ehess(w(:, j)', Y, y, M, u);

      fr_fit(:, j) = trustregions(fr, y0, ops);

    end

    if(length(find(Kmat(:, j))) < 2)

      lc_fit(:, j) = repmat(NaN, 1, 3);

    else

      lc.cost = @(y) get_cost(Kmat(:, j)', Y, y, M);
      lc.egrad = @(y) get_egrad(Kmat(:, j)', Y, y, M);
      lc.ehess = @(y, u) get_ehess(Kmat(:, j)', Y, y, M, u);

      lc_fit(:, j) = trustregions(lc, y0, ops);

    end
    
  end

end











% This function performs Frechet regression for the spherical data simulations in Section 8 of the AOS submission "Frechet Regression for Random Objects" by Petersen and Mueller


function [pm, z, Y_lc, Y_fr] = sphere_sims_SIM(s, nsim, n, tau, h, beta)

  rng(s)
  reg_curve = @(t) [sqrt(1-t.^2).*cos(pi*t), sqrt(1-t.^2).*sin(pi*t), t];
  pm = struct('s', s, 'nsim', nsim, 'n', n, 'tau', tau, 'h', h, 'beta', beta);

  % Generate noise vectors and predictors

  u1 = tau(1)*randn(n, nsim); u2 = tau(1)*randn(n, nsim); % low noise components
  v1 = tau(2)*randn(n, nsim); v2 = tau(2)*randn(n, nsim); % high noise components

  x1 = rand(n, nsim); x2 = rand(n, nsim);

  z = (beta*x1 + (1 - beta.^2)*x2)/(beta+sqrt(1-beta.^2));
  % Regression values at predictors
  
  mreg1 = arrayfun(@(j) reg_curve(z(:, j))', 1:nsim, 'UniformOutput', false);
  %mreg2 = arrayfun(@(j) reg_curve(x2(:, j))', 1:nsim, 'UniformOutput', false);

  % Grids and variable storage

  M = spherefactory(3);
  fr = struct(); lc = struct(); ops = struct();
  fr.M = M; lc.M = M; ops.verbosity = 0;
  %xout = linspace(0, 1, 51);
  
  Y_fr = arrayfun(@(l) zeros(3, size(z,1), length(h)), 1:nsim, 'UniformOutput', false);
%  Y_fr2 = arrayfun(@(l) zeros(3, size(z, 1), length(h2)), 1:nsim, 'UniformOutput', false);
  Y_lc = Y_fr;
%  Y_lc2 = Y_fr2;

  %pool = parpool(12);
  %parfor i = 1:nsim % run simulations in parallel
  for i = 1:nsim

    disp(i)
  	% Generate noisy data
    Y1 = cell2mat(arrayfun(@(j) add_noise(mreg1{i}(:, j), [u1(j, i) u2(j, i)]), 1:size(z,1), 'UniformOutput', false));
  	%Y2 = cell2mat(arrayfun(@(j) add_noise(mreg2{i}(:, j), [v1(j, i) v2(j, i)]), 1:n, 'UniformOutput', false));

    for l = 1:length(h)

      [Y_lc{i}(:, :, l) Y_fr{i}(:, :, l)] = get_sphere_fit_SIM(Y1, z(:, i), h(l));

    end

 %   for l = 1:length(h2)
%
 %     [Y_lc2{i}(:, :, l) Y_fr2{i}(:, :, l)] = get_sphere_fit_SIM(Y1, z(:, i), h2(l));
%
 %   end
%
  end
  %delete(pool)

end










% Sphere simulations for n = 100
% Sphere simulation for nsim = 30
addpath(genpath('Manopt_2.0'))
%addpath sphere_spline

nsim =30;
n=100;
reg_curve = @(t) [sqrt(1-t.^2).*cos(pi*t), sqrt(1-t.^2).*sin(pi*t), t];
beta=0.01:0.05:1;
dvec=repmat(NaN, length(beta), nsim);

%Generating the data from fixed beta value~
b=0.6352;

[pm, z_f, Y_lcf, Y_frf] = sphere_sims_SIM(19845, nsim, n, [0.2 0.35], 0.3 , b);

for r= 1:length(beta)
    
[pm, z, Y_lc, Y_fr] = sphere_sims_SIM(19845, nsim, n, [0.2 0.35], 0.3 , beta(r));

%lambda = 10.^(-5:5); T = 50*[1 5 10 20] + 1; e = 10.^(-(2:6));
%[~, Y_sp1, Y_sp2] = sphere_sims_spline(19845, 15, 20, [0.2 0.35], 10.^lambda, T, e);

%yt = [sqrt(1-z'.^2).*cos(pi*z'), sqrt(1-z'.^2).*sin(pi*z'), z']';

%yout2 = arrayfun(@(l) reg_curve(z(:,l)), 1:nsim, 'UniformOutput', false);
%yout = cell2mat(arrayfun(@(t) reg_curve(t)', z(:,i)),1:nsim, 'UniformOutput', false); 
%yout = arrayfun(@(t) reg_curve(t)', z); 

%M = spherefactory(3);

% ISE and MISE for local constant and local freche fits
%se_fr1 = cellfun(@(z) cell2mat(arrayfun(@(j) arrayfun (@(i) M.dist(yt(:, j), z(:, j, i))^2, 1:length(pm.h1))', 1:length(xout), 'UniformOutput', false)), Y_fr1, 'UniformOutput', false);
%se_lc1 = cellfun(@(z) cell2mat(arrayfun(@(j) arrayfun (@(i) M.dist(yt(:, j), z(:, j, i))^2, 1:length(pm.h1))', 1:length(xout), 'UniformOutput', false)), Y_lc1, 'UniformOutput', false);
%se_fr2 = cellfun(@(z) cell2mat(arrayfun(@(j) arrayfun (@(i) M.dist(yt(:, j), z(:, j, i))^2, 1:length(pm.h2))', 1:length(xout), 'UniformOutput', false)), Y_fr2, 'UniformOutput', false);
%se_lc2 = cellfun(@(z) cell2mat(arrayfun(@(j) arrayfun (@(i) M.dist(yt(:, j), z(:, j, i))^2, 1:length(pm.h2))', 1:length(xout), 'UniformOutput', false)), Y_lc2, 'UniformOutput', false);

%ise_fr1 = cell2mat (cellfun (@(s) trapz(xout, s'), se_fr1, 'UniformOutput', false)')'; mise_fr1 = nanmean(ise_fr1');
%ise_lc1 = cell2mat (cellfun (@(s) trapz(xout, s'), se_lc1, 'UniformOutput', false)')'; mise_lc1 = nanmean(ise_lc1');
%ise_fr2 = cell2mat (cellfun (@(s) trapz(xout, s'), se_fr2, 'UniformOutput', false)')'; mise_fr2 = nanmean(ise_fr2');
%ise_lc2 = cell2mat (cellfun (@(s) trapz(xout, s'), se_lc2, 'UniformOutput', false)')'; mise_lc2 = nanmean(ise_lc2');

% number of simulations which failed to converge at any point of xout at each bandwidth - happens near boundaries of xout for a few simluations for small bandwidths

%hfl_fr1 = arrayfun(@(i) sum(cellfun(@(s) any(isnan(s(i,:))), se_fr1)), 1:length(pm.h1));
%hfl_lc1 = arrayfun(@(i) sum(cellfun(@(s) any(isnan(s(i,:))), se_lc1)), 1:length(pm.h1));
%hfl_fr2 = arrayfun(@(i) sum(cellfun(@(s) any(isnan(s(i,:))), se_fr2)), 1:length(pm.h2));
%hfl_lc2 = arrayfun(@(i) sum(cellfun(@(s) any(isnan(s(i,:))), se_lc2)), 1:length(pm.h2));

% ISE and MISE for spline smoothing

%ise_sp1 = zeros(length(Y_sp1), length(lambda), length(T), length(e)); ise_sp2 = ise_sp1;

%for i = 1:size(ise_sp1, 1)
%  for j = 1:length(lambda)
%    for k = 1:length(T)
%      for l = 1:length(e)

%        ise_sp1(i, j, k, l) = trapz(xout, arrayfun(@(c) M.dist(yt(:, c), Y_sp1{i}(:, c, j, k, l))^2, 1:length(xout)));
%        ise_sp2(i, j, k, l) = trapz(xout, arrayfun(@(c) M.dist(yt(:, c), Y_sp2{i}(:, c, j, k, l))^2, 1:length(xout)));
%
%      end
%    end
%  end
%end

%mise_sp1 = squeeze(nanmean(ise_sp1, 1));
%mise_sp2 = squeeze(nanmean(ise_sp2, 1));

dvec(r,:) = arrayfun(@(i) mean((arrayfun(@(l) acos(Y_frf{i}(:, l)'*Y_fr{i}(:,l)),1:n)).^2), 1:nsim);

end

save sphere_results_n100_nsim30_SIM.mat Y_lc * Y_fr * Y_lcf * Y_frf * dvec

load sphere_results_n100_nsim30_SIM.mat

plot( 0.01:0.05:1, dvec)
xlabel('Beta')
ylabel('MSE')
title('MSE variation for n=100, nsim=30')


