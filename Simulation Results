%The function get_sphere_fit_SIM



%% Get sphere fits for simulations

function [lc_fit fr_fit] = get_sphere_fit_SIM(Y, z, h)

  n = length(z);
  lc_fit = zeros(3, length(z));
  fr_fit = lc_fit;
  M = spherefactory(3);
  ops.verbosity = 0;
  fr.M = M; lc.M = M;

  % Get weights
  zdiff = repmat(z, 1, length(z)) - repmat(z', length(z), 1);
  Kmat = 0.75*(1 - (zdiff/h).^2).*(abs(zdiff)<= h);
  mu0 = mean(Kmat);  mu1 = mean(Kmat.*zdiff); mu2 = mean(Kmat.*(zdiff.^2));
  sig2 = mu0.*mu2 - mu1.^2;
  w = Kmat.*(repmat(mu2, length(z), 1) - repmat(mu1, length(z), 1).*zdiff)./repmat(sig2, length(z), 1);

  for j = 1:length(z)

    y0 = sum(cell2mat(arrayfun(@(k) w(k, j)*Y(:, k), 1:n, 'UniformOutput', false))')'; y0 = y0/norm(y0); % Initial guess (extrinsic)

    %Compute cost and Euclidean gradient

    if(length(find(w(:, j))) < 2)

      fr_fit(:, j) = repmat(NaN, 1, 3);

    else

      fr.cost = @(y) get_cost(w(:, j)', Y, y, M);
      fr.egrad = @(y) get_egrad(w(:, j)', Y, y, M);
      fr.ehess = @(y, u) get_ehess(w(:, j)', Y, y, M, u);

      fr_fit(:, j) = trustregions(fr, y0, ops);

    end

    if(length(find(Kmat(:, j))) < 2)

      lc_fit(:, j) = repmat(NaN, 1, 3);

    else

      lc.cost = @(y) get_cost(Kmat(:, j)', Y, y, M);
      lc.egrad = @(y) get_egrad(Kmat(:, j)', Y, y, M);
      lc.ehess = @(y, u) get_ehess(Kmat(:, j)', Y, y, M, u);

      lc_fit(:, j) = trustregions(lc, y0, ops);

    end
    
  end

end











% This function performs Frechet regression for the spherical data simulations in Section 8 of the AOS submission "Frechet Regression for Random Objects" by Petersen and Mueller


function [pm, z, Y_lc, Y_fr] = sphere_sims_SIM(s, nsim, n, tau, h, beta)

  rng(s)
  reg_curve = @(t) [sqrt(1-t.^2).*cos(pi*t), sqrt(1-t.^2).*sin(pi*t), t];
  pm = struct('s', s, 'nsim', nsim, 'n', n, 'tau', tau, 'h', h, 'beta', beta);

  % Generate noise vectors and predictors

  u1 = tau(1)*randn(n, nsim); u2 = tau(1)*randn(n, nsim); % low noise components
  v1 = tau(2)*randn(n, nsim); v2 = tau(2)*randn(n, nsim); % high noise components

  x1 = rand(n, nsim); x2 = rand(n, nsim);

  z = (beta*x1 + (1 - beta.^2)*x2)/(beta+sqrt(1-beta.^2));
  % Regression values at predictors
  
  mreg1 = arrayfun(@(j) reg_curve(z(:, j))', 1:nsim, 'UniformOutput', false);
  %mreg2 = arrayfun(@(j) reg_curve(x2(:, j))', 1:nsim, 'UniformOutput', false);

  % Grids and variable storage

  M = spherefactory(3);
  fr = struct(); lc = struct(); ops = struct();
  fr.M = M; lc.M = M; ops.verbosity = 0;
  %xout = linspace(0, 1, 51);
  
  Y_fr = arrayfun(@(l) zeros(3, size(z,1), length(h)), 1:nsim, 'UniformOutput', false);
%  Y_fr2 = arrayfun(@(l) zeros(3, size(z, 1), length(h2)), 1:nsim, 'UniformOutput', false);
  Y_lc = Y_fr;
%  Y_lc2 = Y_fr2;

  %pool = parpool(12);
  %parfor i = 1:nsim % run simulations in parallel
  for i = 1:nsim

    disp(i)
  	% Generate noisy data
    Y1 = cell2mat(arrayfun(@(j) add_noise(mreg1{i}(:, j), [u1(j, i) u2(j, i)]), 1:size(z,1), 'UniformOutput', false));
  	%Y2 = cell2mat(arrayfun(@(j) add_noise(mreg2{i}(:, j), [v1(j, i) v2(j, i)]), 1:n, 'UniformOutput', false));

    for l = 1:length(h)

      [Y_lc{i}(:, :, l) Y_fr{i}(:, :, l)] = get_sphere_fit_SIM(Y1, z(:, i), h(l));

    end

 %   for l = 1:length(h2)
%
 %     [Y_lc2{i}(:, :, l) Y_fr2{i}(:, :, l)] = get_sphere_fit_SIM(Y1, z(:, i), h2(l));
%
 %   end
%
  end
  %delete(pool)

end











% Sphere simulations for n = 50

nsim =30;
n=50;
addpath(genpath('Manopt_2.0'))
%addpath sphere_spline

reg_curve = @(t) [sqrt(1-t.^2).*cos(pi*t), sqrt(1-t.^2).*sin(pi*t), t];
beta=0.01:0.08:1;
dvec=repmat(NaN, length(beta), nsim);

for r= 1:length(beta)
    
[pm, z, Y_lc, Y_fr] = sphere_sims_SIM(19845, nsim, n, [0.2 0.35], 0.3 , beta(r));

%lambda = 10.^(-5:5); T = 50*[1 5 10 20] + 1; e = 10.^(-(2:6));
%[~, Y_sp1, Y_sp2] = sphere_sims_spline(19845, 15, 20, [0.2 0.35], 10.^lambda, T, e);

%yt = [sqrt(1-z'.^2).*cos(pi*z'), sqrt(1-z'.^2).*sin(pi*z'), z']';

yout2 = arrayfun(@(l) reg_curve(z(:,l)), 1:nsim, 'UniformOutput', false);
%yout = cell2mat(arrayfun(@(t) reg_curve(t)', z(:,i)),1:nsim, 'UniformOutput', false); 
%yout = arrayfun(@(t) reg_curve(t)', z); 

%M = spherefactory(3);

dvec(r,:) = arrayfun(@(i) mean((arrayfun(@(l) acos(yout2{i}(l, :)*Y_fr{i}(:,l)),1:n)).^2), 1:nsim);

end


plot( 0.01:0.05:1, dvec)
xlabel('Beta')
ylabel('MSE')
title('MSE variation for each of 50 simulations')


